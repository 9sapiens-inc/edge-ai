# C# 클라이언트 연동 가이드

## 목차
1. [개요](#개요)
2. [NuGet 패키지 설치](#nuget-패키지-설치)
3. [기본 클라이언트 구현](#기본-클라이언트-구현)
4. [API 사용 예제](#api-사용-예제)
5. [실시간 이벤트 처리](#실시간-이벤트-처리)
6. [에러 처리](#에러-처리)
7. [성능 최적화](#성능-최적화)
8. [전체 예제 애플리케이션](#전체-예제-애플리케이션)

## 개요

CCTV 위험 감지 시스템은 REST API를 통해 C# 애플리케이션과 통신합니다. 이 가이드는 C# 클라이언트 구현 방법을 상세히 설명합니다.

## NuGet 패키지 설치

```xml
<PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
<PackageReference Include="System.Net.Http" Version="4.3.4" />
<PackageReference Include="Microsoft.Extensions.Http" Version="7.0.0" />
<PackageReference Include="System.Reactive" Version="6.0.0" />
```

또는 Package Manager Console:

```powershell
Install-Package Newtonsoft.Json
Install-Package Microsoft.Extensions.Http
Install-Package System.Reactive
```

## 기본 클라이언트 구현

### 1. 모델 클래스 정의

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace CCTVDangerDetection.Models
{
    public enum SeverityLevel
    {
        LOW,
        MEDIUM,
        HIGH,
        CRITICAL
    }

    public enum DangerType
    {
        [JsonProperty("fire")]
        Fire,
        [JsonProperty("smoke")]
        Smoke,
        [JsonProperty("fall")]
        Fall,
        [JsonProperty("no_helmet")]
        NoHelmet,
        [JsonProperty("danger_zone")]
        DangerZone
    }

    public class Location
    {
        [JsonProperty("x")]
        public int X { get; set; }
        
        [JsonProperty("y")]
        public int Y { get; set; }
        
        [JsonProperty("width")]
        public int Width { get; set; }
        
        [JsonProperty("height")]
        public int Height { get; set; }
    }

    public class Detection
    {
        [JsonProperty("id")]
        public string Id { get; set; }
        
        [JsonProperty("type")]
        public string Type { get; set; }
        
        [JsonProperty("confidence")]
        public double Confidence { get; set; }
        
        [JsonProperty("severity")]
        public string Severity { get; set; }
        
        [JsonProperty("timestamp")]
        public DateTime Timestamp { get; set; }
        
        [JsonProperty("location")]
        public Location Location { get; set; }
        
        [JsonProperty("details")]
        public Dictionary<string, object> Details { get; set; }
        
        [JsonProperty("snapshot_url")]
        public string SnapshotUrl { get; set; }
    }

    public class DetectionResponse
    {
        [JsonProperty("success")]
        public bool Success { get; set; }
        
        [JsonProperty("detections")]
        public List<Detection> Detections { get; set; }
        
        [JsonProperty("frame_id")]
        public string FrameId { get; set; }
        
        [JsonProperty("processing_time")]
        public double ProcessingTime { get; set; }
    }

    public class StreamInfo
    {
        [JsonProperty("stream_id")]
        public string StreamId { get; set; }
        
        [JsonProperty("url")]
        public string Url { get; set; }
        
        [JsonProperty("status")]
        public string Status { get; set; }
        
        [JsonProperty("fps")]
        public double Fps { get; set; }
        
        [JsonProperty("resolution")]
        public Dictionary<string, int> Resolution { get; set; }
        
        [JsonProperty("error_message")]
        public string ErrorMessage { get; set; }
    }
}
```

### 2. HTTP 클라이언트 구현

```csharp
using System;
using System.Net.Http;
using System.Threading.Tasks;
using System.Text;
using Microsoft.Extensions.Logging;

namespace CCTVDangerDetection.Client
{
    public class CCTVDetectionClient : IDisposable
    {
        private readonly HttpClient _httpClient;
        private readonly ILogger<CCTVDetectionClient> _logger;
        private readonly string _baseUrl;
        private readonly string _apiKey;

        public CCTVDetectionClient(
            string baseUrl = "http://localhost:8000",
            string apiKey = null,
            ILogger<CCTVDetectionClient> logger = null)
        {
            _baseUrl = baseUrl.TrimEnd('/');
            _apiKey = apiKey;
            _logger = logger;

            _httpClient = new HttpClient
            {
                BaseAddress = new Uri(_baseUrl),
                Timeout = TimeSpan.FromSeconds(30)
            };

            // 헤더 설정
            _httpClient.DefaultRequestHeaders.Add("Accept", "application/json");
            if (!string.IsNullOrEmpty(_apiKey))
            {
                _httpClient.DefaultRequestHeaders.Add("X-API-Key", _apiKey);
            }
        }

        /// <summary>
        /// 단일 이미지 분석
        /// </summary>
        public async Task<DetectionResponse> AnalyzeImageAsync(
            byte[] imageData, 
            string fileName = "image.jpg",
            string[] detectionTypes = null,
            double minConfidence = 0.5)
        {
            try
            {
                using var content = new MultipartFormDataContent();
                
                // 이미지 추가
                content.Add(new ByteArrayContent(imageData), "file", fileName);
                
                // 옵션 추가
                if (detectionTypes != null && detectionTypes.Length > 0)
                {
                    content.Add(new StringContent(string.Join(",", detectionTypes)), "detection_types");
                }
                content.Add(new StringContent(minConfidence.ToString()), "min_confidence");

                // API 호출
                var response = await _httpClient.PostAsync("/api/v1/detection/analyze", content);
                response.EnsureSuccessStatusCode();

                var json = await response.Content.ReadAsStringAsync();
                return JsonConvert.DeserializeObject<DetectionResponse>(json);
            }
            catch (HttpRequestException ex)
            {
                _logger?.LogError(ex, "HTTP 요청 실패");
                throw new Exception($"API 호출 실패: {ex.Message}", ex);
            }
            catch (TaskCanceledException)
            {
                throw new TimeoutException("API 요청 시간 초과");
            }
        }

        /// <summary>
        /// 파일에서 이미지 분석
        /// </summary>
        public async Task<DetectionResponse> AnalyzeImageFileAsync(
            string filePath,
            string[] detectionTypes = null,
            double minConfidence = 0.5)
        {
            var imageData = await File.ReadAllBytesAsync(filePath);
            var fileName = Path.GetFileName(filePath);
            return await AnalyzeImageAsync(imageData, fileName, detectionTypes, minConfidence);
        }

        /// <summary>
        /// 배치 이미지 분석
        /// </summary>
        public async Task<List<DetectionResponse>> AnalyzeBatchAsync(
            List<byte[]> images,
            string[] detectionTypes = null,
            double minConfidence = 0.5,
            bool parallel = true)
        {
            using var content = new MultipartFormDataContent();

            // 모든 이미지 추가
            for (int i = 0; i < images.Count; i++)
            {
                content.Add(new ByteArrayContent(images[i]), "files", $"image_{i}.jpg");
            }

            // 옵션 추가
            if (detectionTypes != null)
            {
                content.Add(new StringContent(string.Join(",", detectionTypes)), "detection_types");
            }
            content.Add(new StringContent(minConfidence.ToString()), "min_confidence");
            content.Add(new StringContent(parallel.ToString()), "parallel");

            var response = await _httpClient.PostAsync("/api/v1/detection/analyze_batch", content);
            response.EnsureSuccessStatusCode();

            var json = await response.Content.ReadAsStringAsync();
            var batchResponse = JsonConvert.DeserializeObject<BatchDetectionResponse>(json);
            return batchResponse.Results;
        }

        /// <summary>
        /// 스트림 시작
        /// </summary>
        public async Task<StreamInfo> StartStreamAsync(string rtspUrl, int frameSkip = 1)
        {
            var request = new
            {
                url = rtspUrl,
                frame_skip = frameSkip
            };

            var json = JsonConvert.SerializeObject(request);
            var content = new StringContent(json, Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync("/api/v1/stream/start", content);
            response.EnsureSuccessStatusCode();

            var responseJson = await response.Content.ReadAsStringAsync();
            return JsonConvert.DeserializeObject<StreamInfo>(responseJson);
        }

        /// <summary>
        /// 스트림 중지
        /// </summary>
        public async Task<bool> StopStreamAsync(string streamId)
        {
            var response = await _httpClient.PostAsync($"/api/v1/stream/stop/{streamId}", null);
            return response.IsSuccessStatusCode;
        }

        /// <summary>
        /// 스트림 상태 조회
        /// </summary>
        public async Task<StreamInfo> GetStreamStatusAsync(string streamId)
        {
            var response = await _httpClient.GetAsync($"/api/v1/stream/status/{streamId}");
            response.EnsureSuccessStatusCode();

            var json = await response.Content.ReadAsStringAsync();
            return JsonConvert.DeserializeObject<StreamInfo>(json);
        }

        /// <summary>
        /// 헬스 체크
        /// </summary>
        public async Task<bool> CheckHealthAsync()
        {
            try
            {
                var response = await _httpClient.GetAsync("/api/v1/health");
                return response.IsSuccessStatusCode;
            }
            catch
            {
                return false;
            }
        }

        public void Dispose()
        {
            _httpClient?.Dispose();
        }
    }
}
```

## API 사용 예제

### 1. 단일 이미지 분석

```csharp
using var client = new CCTVDetectionClient("http://localhost:8000");

// 파일에서 이미지 분석
var result = await client.AnalyzeImageFileAsync(
    @"C:\images\test.jpg",
    detectionTypes: new[] { "fire", "smoke" },
    minConfidence: 0.7
);

if (result.Success)
{
    Console.WriteLine($"처리 시간: {result.ProcessingTime}ms");
    
    foreach (var detection in result.Detections)
    {
        Console.WriteLine($"감지: {detection.Type}");
        Console.WriteLine($"신뢰도: {detection.Confidence:P}");
        Console.WriteLine($"심각도: {detection.Severity}");
        Console.WriteLine($"위치: X={detection.Location.X}, Y={detection.Location.Y}");
        Console.WriteLine();
    }
}
```

### 2. 웹캠 실시간 분석

```csharp
using OpenCvSharp;
using System.Threading;

public async Task AnalyzeWebcamAsync()
{
    using var client = new CCTVDetectionClient();
    using var capture = new VideoCapture(0); // 웹캠
    using var mat = new Mat();

    while (true)
    {
        capture.Read(mat);
        if (mat.Empty()) break;

        // Mat을 byte[]로 변환
        var imageData = mat.ToBytes(".jpg");

        try
        {
            var result = await client.AnalyzeImageAsync(imageData);
            
            // 결과 처리
            foreach (var detection in result.Detections)
            {
                // UI 업데이트 또는 알림
                OnDangerDetected(detection);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"분석 오류: {ex.Message}");
        }

        // 프레임 레이트 조절
        await Task.Delay(100); // 10 FPS
    }
}
```

### 3. RTSP 스트림 관리

```csharp
public class StreamManager
{
    private readonly CCTVDetectionClient _client;
    private readonly Dictionary<string, StreamInfo> _activeStreams;

    public StreamManager(CCTVDetectionClient client)
    {
        _client = client;
        _activeStreams = new Dictionary<string, StreamInfo>();
    }

    public async Task<string> AddCameraAsync(string rtspUrl, string cameraName)
    {
        try
        {
            var streamInfo = await _client.StartStreamAsync(rtspUrl);
            _activeStreams[cameraName] = streamInfo;
            
            Console.WriteLine($"카메라 추가됨: {cameraName} (ID: {streamInfo.StreamId})");
            return streamInfo.StreamId;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"카메라 추가 실패: {ex.Message}");
            throw;
        }
    }

    public async Task RemoveCameraAsync(string cameraName)
    {
        if (_activeStreams.TryGetValue(cameraName, out var streamInfo))
        {
            await _client.StopStreamAsync(streamInfo.StreamId);
            _activeStreams.Remove(cameraName);
            Console.WriteLine($"카메라 제거됨: {cameraName}");
        }
    }

    public async Task<Dictionary<string, StreamInfo>> GetAllCameraStatusAsync()
    {
        var statuses = new Dictionary<string, StreamInfo>();
        
        foreach (var kvp in _activeStreams)
        {
            var status = await _client.GetStreamStatusAsync(kvp.Value.StreamId);
            statuses[kvp.Key] = status;
        }
        
        return statuses;
    }
}
```

## 실시간 이벤트 처리

### 1. Server-Sent Events (SSE) 클라이언트

```csharp
using System.IO;
using System.Reactive.Linq;
using System.Reactive.Subjects;

public class EventStreamClient : IDisposable
{
    private readonly HttpClient _httpClient;
    private readonly Subject<Detection> _detectionSubject;
    private CancellationTokenSource _cancellationTokenSource;

    public IObservable<Detection> Detections => _detectionSubject.AsObservable();

    public EventStreamClient(string baseUrl)
    {
        _httpClient = new HttpClient { BaseAddress = new Uri(baseUrl) };
        _detectionSubject = new Subject<Detection>();
    }

    public async Task ConnectAsync(string streamId)
    {
        _cancellationTokenSource = new CancellationTokenSource();
        var url = $"/api/v1/detection/realtime/{streamId}";

        try
        {
            using var response = await _httpClient.GetAsync(
                url, 
                HttpCompletionOption.ResponseHeadersRead,
                _cancellationTokenSource.Token
            );

            response.EnsureSuccessStatusCode();

            using var stream = await response.Content.ReadAsStreamAsync();
            using var reader = new StreamReader(stream);

            while (!reader.EndOfStream && !_cancellationTokenSource.Token.IsCancellationRequested)
            {
                var line = await reader.ReadLineAsync();
                
                if (line?.StartsWith("data: ") == true)
                {
                    var json = line.Substring(6);
                    try
                    {
                        var detection = JsonConvert.DeserializeObject<Detection>(json);
                        _detectionSubject.OnNext(detection);
                    }
                    catch (JsonException ex)
                    {
                        Console.WriteLine($"JSON 파싱 오류: {ex.Message}");
                    }
                }
            }
        }
        catch (Exception ex)
        {
            _detectionSubject.OnError(ex);
        }
    }

    public void Disconnect()
    {
        _cancellationTokenSource?.Cancel();
    }

    public void Dispose()
    {
        Disconnect();
        _cancellationTokenSource?.Dispose();
        _detectionSubject?.Dispose();
        _httpClient?.Dispose();
    }
}

// 사용 예제
public async Task MonitorStreamAsync(string streamId)
{
    using var eventClient = new EventStreamClient("http://localhost:8000");
    
    // 이벤트 구독
    var subscription = eventClient.Detections
        .Where(d => d.Severity == "HIGH" || d.Severity == "CRITICAL")
        .Subscribe(
            detection => {
                Console.WriteLine($"위험 감지! 타입: {detection.Type}, 심각도: {detection.Severity}");
                // 알림 발송, UI 업데이트 등
            },
            error => Console.WriteLine($"에러: {error.Message}"),
            () => Console.WriteLine("스트림 종료")
        );

    // 연결 시작
    await eventClient.ConnectAsync(streamId);
}
```

### 2. SignalR을 사용한 실시간 통신 (선택사항)

```csharp
using Microsoft.AspNetCore.SignalR.Client;

public class SignalRClient
{
    private HubConnection _hubConnection;

    public async Task ConnectAsync(string hubUrl)
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(hubUrl)
            .WithAutomaticReconnect()
            .Build();

        // 이벤트 핸들러 등록
        _hubConnection.On<Detection>("OnDetection", detection =>
        {
            Console.WriteLine($"감지: {detection.Type} at {detection.Timestamp}");
        });

        _hubConnection.On<string>("OnStreamError", error =>
        {
            Console.WriteLine($"스트림 오류: {error}");
        });

        await _hubConnection.StartAsync();
    }

    public async Task SubscribeToStreamAsync(string streamId)
    {
        await _hubConnection.InvokeAsync("SubscribeToStream", streamId);
    }

    public async Task UnsubscribeFromStreamAsync(string streamId)
    {
        await _hubConnection.InvokeAsync("UnsubscribeFromStream", streamId);
    }
}
```

## 에러 처리

### 1. 포괄적인 에러 처리

```csharp
public class SafeDetectionClient
{
    private readonly CCTVDetectionClient _client;
    private readonly ILogger<SafeDetectionClient> _logger;
    private readonly int _maxRetries = 3;

    public SafeDetectionClient(CCTVDetectionClient client, ILogger<SafeDetectionClient> logger)
    {
        _client = client;
        _logger = logger;
    }

    public async Task<DetectionResponse> AnalyzeWithRetryAsync(
        byte[] imageData,
        int retryCount = 0)
    {
        try
        {
            return await _client.AnalyzeImageAsync(imageData);
        }
        catch (TimeoutException ex)
        {
            _logger.LogWarning($"요청 시간 초과 (시도 {retryCount + 1}/{_maxRetries})");
            
            if (retryCount < _maxRetries - 1)
            {
                await Task.Delay(TimeSpan.FromSeconds(Math.Pow(2, retryCount))); // 지수 백오프
                return await AnalyzeWithRetryAsync(imageData, retryCount + 1);
            }
            
            throw new Exception($"최대 재시도 횟수 초과: {ex.Message}", ex);
        }
        catch (HttpRequestException ex)
        {
            _logger.LogError(ex, "HTTP 요청 실패");
            
            // 특정 상태 코드 처리
            if (ex.Message.Contains("404"))
            {
                throw new Exception("API 엔드포인트를 찾을 수 없습니다");
            }
            else if (ex.Message.Contains("401"))
            {
                throw new Exception("인증 실패. API 키를 확인하세요");
            }
            else if (ex.Message.Contains("500"))
            {
                throw new Exception("서버 오류가 발생했습니다");
            }
            
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "예상치 못한 오류");
            throw new Exception($"분석 중 오류 발생: {ex.Message}", ex);
        }
    }
}
```

### 2. Circuit Breaker 패턴

```csharp
using Polly;
using Polly.CircuitBreaker;

public class ResilientDetectionClient
{
    private readonly HttpClient _httpClient;
    private readonly IAsyncPolicy<HttpResponseMessage> _retryPolicy;

    public ResilientDetectionClient()
    {
        _httpClient = new HttpClient();

        // Circuit Breaker + Retry 정책
        _retryPolicy = Policy
            .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
            .Or<HttpRequestException>()
            .Or<TaskCanceledException>()
            .CircuitBreakerAsync(
                handledEventsAllowedBeforeBreaking: 3,
                durationOfBreak: TimeSpan.FromSeconds(30),
                onBreak: (result, duration) =>
                {
                    Console.WriteLine($"Circuit breaker 열림. {duration} 동안 대기");
                },
                onReset: () =>
                {
                    Console.WriteLine("Circuit breaker 재설정됨");
                })
            .WrapAsync(
                Policy
                    .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
                    .WaitAndRetryAsync(
                        3,
                        retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),
                        onRetry: (outcome, timespan, retryCount, context) =>
                        {
                            Console.WriteLine($"재시도 {retryCount} after {timespan}");
                        }));
    }

    public async Task<T> ExecuteAsync<T>(Func<Task<HttpResponseMessage>> operation)
    {
        var response = await _retryPolicy.ExecuteAsync(operation);
        response.EnsureSuccessStatusCode();
        
        var json = await response.Content.ReadAsStringAsync();
        return JsonConvert.DeserializeObject<T>(json);
    }
}
```

## 성능 최적화

### 1. 이미지 전처리 및 압축

```csharp
using System.Drawing;
using System.Drawing.Imaging;

public static class ImageOptimizer
{
    public static byte[] OptimizeImage(byte[] originalImage, int maxWidth = 1920, int quality = 85)
    {
        using var ms = new MemoryStream(originalImage);
        using var image = Image.FromStream(ms);
        
        // 리사이즈 필요 여부 확인
        if (image.Width <= maxWidth)
        {
            return originalImage;
        }

        // 비율 유지하며 리사이즈
        var ratio = (double)maxWidth / image.Width;
        var newWidth = maxWidth;
        var newHeight = (int)(image.Height * ratio);

        using var resized = new Bitmap(newWidth, newHeight);
        using var graphics = Graphics.FromImage(resized);
        
        graphics.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality;
        graphics.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;
        graphics.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;
        
        graphics.DrawImage(image, 0, 0, newWidth, newHeight);

        // JPEG로 압축
        using var output = new MemoryStream();
        var encoder = ImageCodecInfo.GetImageEncoders().First(c => c.FormatID == ImageFormat.Jpeg.Guid);
        var encoderParams = new EncoderParameters(1);
        encoderParams.Param[0] = new EncoderParameter(Encoder.Quality, quality);
        
        resized.Save(output, encoder, encoderParams);
        return output.ToArray();
    }
}
```

### 2. 연결 풀링 및 재사용

```csharp
public class DetectionClientFactory
{
    private static readonly Dictionary<string, CCTVDetectionClient> _clients = new();
    private static readonly object _lock = new();

    public static CCTVDetectionClient GetClient(string baseUrl, string apiKey = null)
    {
        var key = $"{baseUrl}:{apiKey}";
        
        lock (_lock)
        {
            if (!_clients.ContainsKey(key))
            {
                _clients[key] = new CCTVDetectionClient(baseUrl, apiKey);
            }
            
            return _clients[key];
        }
    }

    public static void DisposeAll()
    {
        lock (_lock)
        {
            foreach (var client in _clients.Values)
            {
                client.Dispose();
            }
            _clients.Clear();
        }
    }
}
```

## 전체 예제 애플리케이션

### WPF 애플리케이션 예제

```csharp
using System.Windows;
using System.Windows.Media.Imaging;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace CCTVMonitor
{
    public partial class MainWindow : Window, INotifyPropertyChanged
    {
        private readonly CCTVDetectionClient _client;
        private readonly DispatcherTimer _timer;
        private BitmapImage _currentFrame;
        private ObservableCollection<Detection> _detections;

        public BitmapImage CurrentFrame
        {
            get => _currentFrame;
            set
            {
                _currentFrame = value;
                OnPropertyChanged();
            }
        }

        public ObservableCollection<Detection> Detections
        {
            get => _detections;
            set
            {
                _detections = value;
                OnPropertyChanged();
            }
        }

        public MainWindow()
        {
            InitializeComponent();
            DataContext = this;

            _client = new CCTVDetectionClient("http://localhost:8000");
            _detections = new ObservableCollection<Detection>();

            _timer = new DispatcherTimer
            {
                Interval = TimeSpan.FromMilliseconds(100)
            };
            _timer.Tick += Timer_Tick;
        }

        private async void StartButton_Click(object sender, RoutedEventArgs e)
        {
            var rtspUrl = RtspUrlTextBox.Text;
            
            try
            {
                var streamInfo = await _client.StartStreamAsync(rtspUrl);
                StreamIdLabel.Content = $"Stream ID: {streamInfo.StreamId}";
                
                // 실시간 이벤트 모니터링 시작
                _ = Task.Run(() => MonitorEventsAsync(streamInfo.StreamId));
                
                _timer.Start();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"오류: {ex.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private async Task MonitorEventsAsync(string streamId)
        {
            using var eventClient = new EventStreamClient("http://localhost:8000");
            
            eventClient.Detections.Subscribe(detection =>
            {
                Dispatcher.Invoke(() =>
                {
                    Detections.Add(detection);
                    
                    // 최근 10개만 유지
                    while (Detections.Count > 10)
                    {
                        Detections.RemoveAt(0);
                    }

                    // 심각한 위험 알림
                    if (detection.Severity == "CRITICAL")
                    {
                        ShowCriticalAlert(detection);
                    }
                });
            });

            await eventClient.ConnectAsync(streamId);
        }

        private void ShowCriticalAlert(Detection detection)
        {
            var alert = new Window
            {
                Title = "긴급 위험 감지!",
                Width = 400,
                Height = 200,
                WindowStartupLocation = WindowStartupLocation.CenterScreen,
                Topmost = true
            };

            var content = new TextBlock
            {
                Text = $"위험 타입: {detection.Type}\n" +
                       $"심각도: {detection.Severity}\n" +
                       $"신뢰도: {detection.Confidence:P}\n" +
                       $"시간: {detection.Timestamp:HH:mm:ss}",
                Margin = new Thickness(20),
                FontSize = 16
            };

            alert.Content = content;
            alert.ShowDialog();
        }

        private async void Timer_Tick(object sender, EventArgs e)
        {
            // 주기적으로 현재 프레임 업데이트
            // 실제 구현에서는 스트림에서 프레임을 가져와야 함
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
```

## 모범 사례

1. **연결 관리**
   - HttpClient를 재사용하여 연결 오버헤드 감소
   - 적절한 타임아웃 설정

2. **에러 처리**
   - 재시도 로직 구현
   - Circuit Breaker 패턴 사용
   - 의미 있는 에러 메시지 제공

3. **성능**
   - 이미지 크기 최적화
   - 비동기 처리 활용
   - 배치 처리로 네트워크 호출 감소

4. **보안**
   - HTTPS 사용
   - API 키 안전한 보관
   - 입력 검증

5. **모니터링**
   - 로깅 구현
   - 성능 메트릭 수집
   - 알림 시스템 구축